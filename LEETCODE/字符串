28.实现strstr()
思路https://www.cnblogs.com/grandyang/p/4606696.html
def strStr(self, haystack: str, needle: str) -> int:
        if  needle=="":
            return 0
        start=0
        m=len(haystack)
        n=len(needle)
        for i in range(m-n+1):
            #用h记录已出现子串长度
            h=0
            for j in range(n):
                if needle[j]==haystack[i+j]:
                    h+=1
                else:
                    break
            if h==n:
                return i
        return -1
224.基本计算器
思路https://zhuanlan.zhihu.com/p/80856496
#将括号外的放进stack里，处理好括号内的项，再将括号外的从stack弹出与括号内的项进行计算。
def calculate(self, s: str) -> int:
        res = 0
        stack = []
        #sign表示加上一个负数和正数
        sign = 1
        i = 0
        n = len(s)
        while i < n:
            if s[i] == " ":
                i += 1
            elif s[i] == "-":
                sign = -1
                i += 1
            elif s[i] == "+":
                sign = 1
                i += 1
            elif s[i] == "(":
                stack.append(res)
                stack.append(sign)
                res = 0
                sign = 1
                i += 1
            #当“）”时，对stack里元素（括号外的res）和括号内的res进行计算
            elif s[i] == ")":
                # print(stack)
                res = res * stack.pop() + stack.pop()
                i += 1
            elif s[i].isdigit():
                tmp = int(s[i])
                i += 1
                while i < n and s[i].isdigit():
                    tmp = tmp * 10 + int(s[i])
                    i += 1
                #会对括号之间的所有项进行计算
                res += tmp * sign
        return res
题目227 基本计算器 II
思路：将乘除项先求出，使得等式只剩下加减项，将这些项都放在stack里，最后进行计算
def calculate(s) :
    n = len(s)
    sign = 1
    stack = []
    i=0
    while i < n:
        if "0" <= s[i] <= "9":
            tem = int(s[i])
            i += 1
            while i < n and "0" <= s[i] <= "9":
                tem = tem * 10 + int(s[i])
                i += 1
            stack.append(int(tem))
            while len(stack) > 1 and stack[-2] in {"*", "/"}:
                stack.pop()
                opt = stack.pop()
                if opt == "*":
                    stack.append(stack.pop() * tem)
                else:
                    stack.append(stack.pop() // tem)
        elif s[i] in {"*", "/", "+", "-"}:
            stack.append(s[i])
            i += 1
        else:
            i += 1
    res = 0
    #print(stack)
    for i in stack:
        if i == "+":
            sign = 1
        elif i == "-":
            sign = -1
        else:
            #print(sign * i,stack)
            res = res + (sign * i)
    return res
题目125 验证回文串
只考虑字母和数字字符，可以忽略字母的大小写，所以忽略所有不是字母和数字的字符，并将大写字母转化为小写。
思路https://zhuanlan.zhihu.com/p/68267699
def strStr(s) :
    def p(a):
        if "A" <= a <= "Z":
            a = chr(ord(a) - ord("A") + ord("a"))
        return a

    n = len(s)
    if n == 0:
        return True
    l = 0
    r = n - 1
    while l < r:
        #if语句使得while必须不断迭代，直至开头和结尾都只能是字母或数字
        if not ("A"<=s[l]<="Z" or "0"<=s[l]<="9" or "a"<=s[l]<="z"):
            l+=1
        elif not ("A"<=s[r]<="Z" or "0"<=s[r]<="9" or "a"<=s[r]<="z"):
            r-=1
        else:
            if p(s[l])!=p(s[r]):
                return False
            l+=1
            r-=1
    return True
91.解码方法
思路https://zhuanlan.zhihu.com/p/61950266
类似爬楼梯
def numDecodings(self, s: str) -> int:
        n=len(s)
        dp=[0 for i in range(n)]
        if s[0]=="0":
            return 0
        else:
            dp[0]=1
        if n<2:
            return dp[0]
        if 10<=int(s[:2])<=26:
            if s[1]!="0":
                dp[1]=2
            else:
                dp[1]=1
        else:
            if s[1]!="0":
                dp[1]=1
            else:
                return 0
        for i in range(2,n):
            if 10<=int(s[i-1]+s[i])<=26:
                if s[i]!="0":
                    dp[i]=dp[i-1]+dp[i-2]
                else:
                    dp[i]=dp[i-2]
            else:
                if s[i]!="0":
                    dp[i]=dp[i-1]
                else:
                    return 0
        return dp[-1]
49. 字母异位词分组
s思路https://zhuanlan.zhihu.com/p/45596463
def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = {}
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            if tuple(count) in ans:
                #由于list不能作为dict的key，所以转化为tuple即可
                ans[tuple(count)].append(s)
            else:
                ans[tuple(count)]=[s]
        return ans.values()
44通配符匹配
https://zhuanlan.zhihu.com/p/65737469的动态规划
dp[i][j]表示s到i位置,p到j位置是否匹配!
初始化:
dp[0][0]:什么都没有,所以为true
第一行dp[0][j],换句话说,s为空,与p匹配,所以只要p开始为*才为true
第一列dp[i][0],当然全部为False
动态方程:
如果(s[i] == p[j] || p[j] == "?") && dp[i-1][j-1] ,有dp[i][j] = true
如果p[j] == "*" && (dp[i-1][j] = true || dp[i][j-1] = true)有dp[i][j] = true
​ note:
​ dp[i-1][j],表示*代表是空字符,例如ab,ab*
​ dp[i][j-1],表示*代表非空任何字符,例如abcd,ab*
def isMatch(self, s: str, p: str) -> bool:
        m=len(s)
        n=len(p)
        dp=[[False]*(n+1) for i in range(m+1)]
        dp[0][0]=True
        for i in range(1,n+1):
            #当p的开头都是“*”时，为true
            if p[i-1]=="*":
                dp[0][i]=dp[0][i-1]
        for i in range(1,m+1):
            for j in range(1,n+1):
                #用i-1而不是i，因为这是dp长度是m+1
                if s[i-1]==p[j-1] or p[j-1]=="?":
                    #只有前面的子串都相同才为True，不能直接复制true
                    dp[i][j]=dp[i-1][j-1]
                if p[j-1]=="*":
                    dp[i][j]=dp[i-1][j] or dp[i][j-1]
        return dp[-1][-1]
22.括号生成
思路：回溯https://zhuanlan.zhihu.com/p/63880192
def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def helper(s="",l=0,r=0):
            #3个if解决问题
            if len(s)==2*n:
                res.append(s)
                return
            if l<n:
                helper(s+"(",l+1,r)
            #右括号数量比左括号数量小
            if r<l:
                helper(s+")",l,r+1)
        helper()
        return res
