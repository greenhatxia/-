28.实现strstr()
思路https://www.cnblogs.com/grandyang/p/4606696.html
def strStr(self, haystack: str, needle: str) -> int:
        if  needle=="":
            return 0
        start=0
        m=len(haystack)
        n=len(needle)
        for i in range(m-n+1):
            #用h记录已出现子串长度
            h=0
            for j in range(n):
                if needle[j]==haystack[i+j]:
                    h+=1
                else:
                    break
            if h==n:
                return i
        return -1
224.基本计算器
思路https://zhuanlan.zhihu.com/p/80856496
#将括号外的放进stack里，处理好括号内的项，再将括号外的从stack弹出与括号内的项进行计算。
def calculate(self, s: str) -> int:
        res = 0
        stack = []
        #sign表示加上一个负数和正数
        sign = 1
        i = 0
        n = len(s)
        while i < n:
            if s[i] == " ":
                i += 1
            elif s[i] == "-":
                sign = -1
                i += 1
            elif s[i] == "+":
                sign = 1
                i += 1
            elif s[i] == "(":
                stack.append(res)
                stack.append(sign)
                res = 0
                sign = 1
                i += 1
            #当“）”时，对stack里元素（括号外的res）和括号内的res进行计算
            elif s[i] == ")":
                # print(stack)
                res = res * stack.pop() + stack.pop()
                i += 1
            elif s[i].isdigit():
                tmp = int(s[i])
                i += 1
                while i < n and s[i].isdigit():
                    tmp = tmp * 10 + int(s[i])
                    i += 1
                #会对括号之间的所有项进行计算
                res += tmp * sign
        return res
题目227 基本计算器 II
思路：将乘除项先求出，使得等式只剩下加减项，将这些项都放在stack里，最后进行计算
def calculate(s) :
    n = len(s)
    sign = 1
    stack = []
    i=0
    while i < n:
        if "0" <= s[i] <= "9":
            tem = int(s[i])
            i += 1
            while i < n and "0" <= s[i] <= "9":
                tem = tem * 10 + int(s[i])
                i += 1
            stack.append(int(tem))
            while len(stack) > 1 and stack[-2] in {"*", "/"}:
                stack.pop()
                opt = stack.pop()
                if opt == "*":
                    stack.append(stack.pop() * tem)
                else:
                    stack.append(stack.pop() // tem)
        elif s[i] in {"*", "/", "+", "-"}:
            stack.append(s[i])
            i += 1
        else:
            i += 1
    res = 0
    #print(stack)
    for i in stack:
        if i == "+":
            sign = 1
        elif i == "-":
            sign = -1
        else:
            #print(sign * i,stack)
            res = res + (sign * i)
    return res
题目125 验证回文串
只考虑字母和数字字符，可以忽略字母的大小写，所以忽略所有不是字母和数字的字符，并将大写字母转化为小写。
思路https://zhuanlan.zhihu.com/p/68267699
def strStr(s) :
    def p(a):
        if "A" <= a <= "Z":
            a = chr(ord(a) - ord("A") + ord("a"))
        return a

    n = len(s)
    if n == 0:
        return True
    l = 0
    r = n - 1
    while l < r:
        #if语句使得while必须不断迭代，直至开头和结尾都只能是字母或数字
        if not ("A"<=s[l]<="Z" or "0"<=s[l]<="9" or "a"<=s[l]<="z"):
            l+=1
        elif not ("A"<=s[r]<="Z" or "0"<=s[r]<="9" or "a"<=s[r]<="z"):
            r-=1
        else:
            if p(s[l])!=p(s[r]):
                return False
            l+=1
            r-=1
    return True
91.解码方法
思路https://zhuanlan.zhihu.com/p/61950266
类似爬楼梯
def numDecodings(self, s: str) -> int:
        n=len(s)
        dp=[0 for i in range(n)]
        if s[0]=="0":
            return 0
        else:
            dp[0]=1
        if n<2:
            return dp[0]
        if 10<=int(s[:2])<=26:
            if s[1]!="0":
                dp[1]=2
            else:
                dp[1]=1
        else:
            if s[1]!="0":
                dp[1]=1
            else:
                return 0
        for i in range(2,n):
            if 10<=int(s[i-1]+s[i])<=26:
                if s[i]!="0":
                    dp[i]=dp[i-1]+dp[i-2]
                else:
                    dp[i]=dp[i-2]
            else:
                if s[i]!="0":
                    dp[i]=dp[i-1]
                else:
                    return 0
        return dp[-1]
49. 字母异位词分组
s思路https://zhuanlan.zhihu.com/p/45596463
def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = {}
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            if tuple(count) in ans:
                ans[tuple(count)].append(s)
            else:
                ans[tuple(count)]=[s]
        return ans.values()
