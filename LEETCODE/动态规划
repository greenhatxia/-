LeetCode 338 Counting Bits
这道题比较特别的地方是它要你计算从0到n的所有数的二进制形式的1的个数。这个时候很容易想到可以用动态规划来做，
即某个数可以用前面的数得到的结果根据某种特点得到它。这道题要我们计算二进制的1的个数，
我们可以通过i/2的数的1的个数再加上它的最后一位得到。 
这种做法的时间复杂度是O(n)，空间复杂度是O(1)
思路https://blog.csdn.net/westbrook1998/article/details/80152822
def countBits(self, num: int) -> List[int]:
        res=[0]*(num+1)
        for i in range(1,num+1):
            res[i]=res[i&(i-1)]+1
        return res
easy
53. 最大子序和
def maxSubArray(self, nums: List[int]) -> int:
    pre=0
    max_val=nums[0]
    start=0
    length=len(nums)
    for i in range(length):
        pre+=nums[i]
        max_val=max(max_val,pre)
        if pre<=0:
            pre=0            
    return max_val
121.买卖股票
def maxProfit(self, prices: List[int]) -> int:
        if len(prices)==0:
            return 0
        res=0
        #buy不是0
        buy=prices[0]
        #卖只能在买之后，迭代到的每个元素都是卖股票的机会，记录下每次获利；
        for i in range(len(prices)):
            if prices[i]<buy:
                buy=prices[i]
            else:
                res=max(res,prices[i]-buy)
        return res
122。买卖股票II
思路：贪心算法https://www.cnblogs.com/xingyunblog/p/8907084.html

def maxProfit(self, prices: List[int]) -> int:
    if len(prices) == 0:
        return 0
    res = 0
    for i in range(len(prices)):
        #同一天卖出后还可以买进，这样即使后面有更大的卖价也不会损失，总之在比买价低的价格出现之前将它卖掉。
        if i+1<len(prices) and prices[i]<prices[i+1]:
            res+=(prices[i+1]-prices[i])
    return res
198.打家劫舍
思路就是跳楼梯稍微变化https://blog.csdn.net/zwzsdy/article/details/80155649
def rob(self, nums: List[int]) -> int:
    if len(nums)==0:
        return 0
    if len(nums)==1:
        return nums[0]
    if len(nums)==2:
        return max(nums[0],nums[1])
    res=[0 for i in range(len(nums))]
    res[0]=nums[0]
    res[1]=max(nums[0],nums[1])
    for i in range(2,len(nums)):
        res[i]=max(res[i-1],res[i-2]+nums[i])
    return res[-1]
