题目：从尾到头打印链表
很简单，先得到正向，再翻转
def printListFromTailToHead(self, listNode):
        if not listNode:
            return []
        result=[]
        while listNode:
            result.append(listNode.val)
            listNode=listNode.next
        #下面的代码就是一个list翻转操作
        length=len(result)
        start=0
        end=length-1
        while start<end:
            a=result[end]
            result[end]=result[start]
            result[start]=a
            end-=1
            start+=1
        return result
题目：链表中倒数第k个节点
代码来自：https://cuijiahua.com/blog/2017/12/basis_14.html
def FindKthToTail(self, head, k):
        if head == None or k == 0:
            return None
        pbefore=head
        pbehind=head
        for i in range(k-1):#防止k大于链表长度
            if pbefore.next!=None:
                pbefore=pbefore.next
            else:
                return None
        while pbefore.next!= None:
            pbefore=pbefore.next
            pbehind=pbehind.next
        return pbehind
题目：反转链表
书上的思路143
def ReverseList(self, p):
        if not p:
            return None
        pre=None
        while p:
            pnext=p.next
            p.next=pre
            pre=p
            p=pnext
        return pre#返回的是pre
        
题目：合并两个排序的链表
思路书上的147，采用递归，我想用循环没做出来
def Merge(self, p1, p2):
        if p1==None:
            return p2
        if p2==None:
            return p1
        p=None
        if(p1.val<p2.val):
            p=p1
            p.next=self.Merge(p1.next,p2)
        else:
            p=p2
            p.next=self.Merge(p1,p2.next)
        return p
题目：复杂链表的复刻
根据书189改写成python，
def Clone(self, p):
        if not p:
            return None
        dummy = p
        while dummy:
            dnext=dummy.next
            pcopy=RandomListNode(dummy.label)
            pcopy.next=dnext
            dummy.next=pcopy
            dummy=pcopy.next
        dummy=p
        while dummy:
            s=dummy.random
            dnext=dummy.next
            if dummy.random!=None:
                dnext.random=s.next
            dummy=dnext.next
        dummy=p
        copyHead=dummy.next#涉及对python赋值的理解，class是不可变对象（list、dict）
        while dummy:
            copyNode = dummy.next
            dummynext = copyNode.next
            dummy.next = dummynext
            if dummynext:#判断原链表是否还有剩下节点
                copyNode.next = dummynext.next
            else:
                copyNode.next = None
            dummy = dummynext
        return copyHead
