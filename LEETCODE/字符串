28.实现strstr()
思路https://www.cnblogs.com/grandyang/p/4606696.html
def strStr(self, haystack: str, needle: str) -> int:
        if  needle=="":
            return 0
        start=0
        m=len(haystack)
        n=len(needle)
        for i in range(m-n+1):
            #用h记录已出现子串长度
            h=0
            for j in range(n):
                if needle[j]==haystack[i+j]:
                    h+=1
                else:
                    break
            if h==n:
                return i
        return -1
224.基本计算器
思路https://zhuanlan.zhihu.com/p/80856496
#将括号外的放进stack里，处理好括号内的项，再将括号外的从stack弹出与括号内的项进行计算。
def calculate(self, s: str) -> int:
        res = 0
        stack = []
        #sign表示加上一个负数和正数
        sign = 1
        i = 0
        n = len(s)
        while i < n:
            if s[i] == " ":
                i += 1
            elif s[i] == "-":
                sign = -1
                i += 1
            elif s[i] == "+":
                sign = 1
                i += 1
            elif s[i] == "(":
                stack.append(res)
                stack.append(sign)
                res = 0
                sign = 1
                i += 1
            #当“）”时，对stack里元素（括号外的res）和括号内的res进行计算
            elif s[i] == ")":
                # print(stack)
                res = res * stack.pop() + stack.pop()
                i += 1
            elif s[i].isdigit():
                tmp = int(s[i])
                i += 1
                while i < n and s[i].isdigit():
                    tmp = tmp * 10 + int(s[i])
                    i += 1
                #会对括号之间的所有项进行计算
                res += tmp * sign
        return res
题目227 基本计算器 II
思路：将乘除项先求出，使得等式只剩下加减项，将这些项都放在stack里，最后进行计算
def calculate(s) :
    n = len(s)
    sign = 1
    stack = []
    i=0
    while i < n:
        if "0" <= s[i] <= "9":
            tem = int(s[i])
            i += 1
            while i < n and "0" <= s[i] <= "9":
                tem = tem * 10 + int(s[i])
                i += 1
            stack.append(int(tem))
            while len(stack) > 1 and stack[-2] in {"*", "/"}:
                stack.pop()
                opt = stack.pop()
                if opt == "*":
                    stack.append(stack.pop() * tem)
                else:
                    stack.append(stack.pop() // tem)
        elif s[i] in {"*", "/", "+", "-"}:
            stack.append(s[i])
            i += 1
        else:
            i += 1
    res = 0
    #print(stack)
    for i in stack:
        if i == "+":
            sign = 1
        elif i == "-":
            sign = -1
        else:
            #print(sign * i,stack)
            res = res + (sign * i)
    return res
题目125 验证回文串
只考虑字母和数字字符，可以忽略字母的大小写，所以忽略所有不是字母和数字的字符，并将大写字母转化为小写。
思路https://zhuanlan.zhihu.com/p/68267699
def strStr(s) :
    def p(a):
        if "A" <= a <= "Z":
            a = chr(ord(a) - ord("A") + ord("a"))
        return a

    n = len(s)
    if n == 0:
        return True
    l = 0
    r = n - 1
    while l < r:
        #if语句使得while必须不断迭代，直至开头和结尾都只能是字母或数字
        if not ("A"<=s[l]<="Z" or "0"<=s[l]<="9" or "a"<=s[l]<="z"):
            l+=1
        elif not ("A"<=s[r]<="Z" or "0"<=s[r]<="9" or "a"<=s[r]<="z"):
            r-=1
        else:
            if p(s[l])!=p(s[r]):
                return False
            l+=1
            r-=1
    return True
91.解码方法
思路https://zhuanlan.zhihu.com/p/61950266
类似爬楼梯
def numDecodings(self, s: str) -> int:
        n=len(s)
        dp=[0 for i in range(n)]
        if s[0]=="0":
            return 0
        else:
            dp[0]=1
        if n<2:
            return dp[0]
        if 10<=int(s[:2])<=26:
            if s[1]!="0":
                dp[1]=2
            else:
                dp[1]=1
        else:
            if s[1]!="0":
                dp[1]=1
            else:
                return 0
        for i in range(2,n):
            if 10<=int(s[i-1]+s[i])<=26:
                if s[i]!="0":
                    dp[i]=dp[i-1]+dp[i-2]
                else:
                    dp[i]=dp[i-2]
            else:
                if s[i]!="0":
                    dp[i]=dp[i-1]
                else:
                    return 0
        return dp[-1]
49. 字母异位词分组
s思路https://zhuanlan.zhihu.com/p/45596463
def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        ans = {}
        for s in strs:
            count = [0] * 26
            for c in s:
                count[ord(c) - ord('a')] += 1
            if tuple(count) in ans:
                #由于list不能作为dict的key，所以转化为tuple即可
                ans[tuple(count)].append(s)
            else:
                ans[tuple(count)]=[s]
        return ans.values()
44通配符匹配
https://zhuanlan.zhihu.com/p/65737469的动态规划
dp[i][j]表示s到i位置,p到j位置是否匹配!
初始化:
dp[0][0]:什么都没有,所以为true
第一行dp[0][j],换句话说,s为空,与p匹配,所以只要p开始为*才为true
第一列dp[i][0],当然全部为False
动态方程:
如果(s[i] == p[j] || p[j] == "?") && dp[i-1][j-1] ,有dp[i][j] = true
如果p[j] == "*" && (dp[i-1][j] = true || dp[i][j-1] = true)有dp[i][j] = true
​ note:
​ dp[i-1][j],表示*代表是空字符,例如ab,ab*
​ dp[i][j-1],表示*代表非空任何字符,例如abcd,ab*
def isMatch(self, s: str, p: str) -> bool:
        m=len(s)
        n=len(p)
        dp=[[False]*(n+1) for i in range(m+1)]
        dp[0][0]=True
        for i in range(1,n+1):
            #当p的开头都是“*”时，为true
            if p[i-1]=="*":
                dp[0][i]=dp[0][i-1]
        for i in range(1,m+1):
            for j in range(1,n+1):
                #用i-1而不是i，因为这是dp长度是m+1
                if s[i-1]==p[j-1] or p[j-1]=="?":
                    #只有前面的子串都相同才为True，不能直接复制true
                    dp[i][j]=dp[i-1][j-1]
                if p[j-1]=="*":
                    dp[i][j]=dp[i-1][j] or dp[i][j-1]
        return dp[-1][-1]
22.括号生成
思路：回溯https://zhuanlan.zhihu.com/p/42290054
如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。
def generateParenthesis(self, n: int) -> List[str]:
        res = []
        def helper(s="",l=0,r=0):
            #3个if解决问题
            if len(s)==2*n:
                res.append(s)
                return
            if l<n:
                helper(s+"(",l+1,r)
            #右括号数量比左括号数量小
            if r<l:
                helper(s+")",l,r+1)
        helper()
        return res
17 电话号码的字母组合
思路：简单的迭代即可https://zhuanlan.zhihu.com/p/53219687
def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        digit2chars = {
            "2": "abc",
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        res = [""]
        #list最多只能有2个for，所以只能把digits的迭代放到外面
        for i in digits:
            res = [k + j for k in res for j in digit2chars[i] ]
        return res
13罗马数字转整数
思路https://zhuanlan.zhihu.com/p/68393125
从左往右，不断加上对应整数值，当出现当前整数比上一个大时（只会出现在是s[i]是s[i-1]的4倍和10倍这两种情况），
由于上一个整数已经加过，所以需要减去之前加的部分（4倍变3倍，9倍变8倍）
def romanToInt(self, s: str) -> int:
        n = len(s)
        convert = {'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1}
        res = convert[s[0]]
        for i in range(1,n):
            if convert[s[i]]>convert[s[i-1]]:
                if convert[s[i]]//convert[s[i-1]]==5:
                    res +=convert[s[i-1]]*3
                else:
                    res+=convert[s[i-1]]*8
            else:
                res+=convert[s[i]]
        return res
8字符串转换整数
思路https://zhuanlan.zhihu.com/p/62875727
def myAtoi(self, str: str) -> int:
        str = str.strip()
        res = ""
        n = len(str)
        i = 0
        #已经去掉空格，剩下的只能有数字、非数字、正负号
        #如果字符串是“+”或“—”，则int（+）会出错，return 0
        if n>0 and str[i] in ["-","+"] and n > 1:
            res += str[i]
            i += 1
        while i<n:
            if "0"<=str[i]<="9":
                res+=str[i]
                i+=1
            else:
                break
        try:
            num = int(res)
            if (-2 ** 31) <= num <= (2 ** 31 - 1):
                return num
            else:
                if num < 0:
                    return -2 ** 31
                else:
                    return 2 ** 31 - 1
        except:
            return  0
3.无重复字符的最长子串
思路：书上300
cur记录长度
def lengthOfLongestSubstring(self, str: str) -> int:
            if len(str)==0:
                return 0
            where={}
            n=len(str)
            pre=-1
            len1=0
            for i in range(n):
                if str[i] in where:
                    pre=max(pre,where[str[i]])
                cur=i-pre
                len1=max(len1,cur)
                where[str[i]]=i
            return len1
20.有效的括号
思路：官方答案https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/
如果只有圆括号，则只需把字典中的括号改到只剩一种即可
def isValid(self, s: str) -> bool:
        stack = []
        mapping = {")": "(", "}": "{", "]": "["}
        # For every bracket in the expression.
        for char in s:
            # If the character is an closing bracket
            if char in mapping:
                # Pop the topmost element from the stack, if it is non empty
                # Otherwise assign a dummy value of '#' to the top_element variable
                top_element = stack.pop() if stack else '#'
                # The mapping for the opening bracket in our hash and the top
                # element of the stack don't match, return False
                if mapping[char] != top_element:
                    return False
            else:
                # We have an opening bracket, simply push it onto the stack.
                stack.append(char)
        # In the end, if the stack is empty, then we have a valid expression.
        # The stack won't be empty for cases like ((()
        return not stack
