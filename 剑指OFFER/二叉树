题目：重建二叉树
书上思路63，代码来源https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6
def reConstructBinaryTree(self, pre, tin):
        if len(pre) == 0:
            return None
        else:
            root = TreeNode(pre[0])
            pos = tin.index(pre[0])#可用enumerate
            root.left = self.reConstructBinaryTree(pre[1:pos+1], tin[:pos])
            root.right = self.reConstructBinaryTree(pre[pos+1:], tin[pos+1:])
        return root
        
        
题目：树的子结构
链接：https://www.nowcoder.com/questionTerminal/6e196c44c7004d15b1610b9afca8bd88
def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        result = False
        if pRoot1 != None and pRoot2 != None:
                result = self.DoesTree1haveTree2(pRoot1, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.left, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.right, pRoot2)
        return result
    # 用于递归判断树的每个节点是否相同
    # 需要注意的地方是: 前两个if语句不可以颠倒顺序
    # 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误
    def DoesTree1haveTree2(self, pRoot1, pRoot2):
        if pRoot2 == None:
            return True
        if pRoot1 == None:
            return False
        if pRoot1.val != pRoot2.val:#比较的是val，不能if p1!=p2
            return False
        return self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) and self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)
题目：平衡二叉树
算法复杂度O(N)即书中的第二种方法，从下往上
链接：https://www.nowcoder.com/questionTerminal/8b3b95850edb4115918ecebdf1b4d222
class Solution:
    def IsBalanced_Solution(self, p):
        # write code here
        return self.dfs(p) != -1
    def dfs(self, p):
        if p is None:
            return 0
        left = self.dfs(p.left)
        if left==-1:#判断左子树是否平衡
            return -1
        right = self.dfs(p.right)
        if right==-1:#判断右子树是否平衡
            return -1
        if abs(left-right)>1:#判断本节点是否平衡
            return -1
        return max(left,right)+1#计算深度
题目：二叉树的下一个结点
def GetNext(self, pNode):
        # write code here
        if pNode.right:#有右子树
            p=pNode.right
            while p.left:
                p=p.left
            return p
        while pNode.next:#无右子树，则找第一个当前节点是父节点左孩子的节点
            if(pNode.next.left==pNode):
                return pNode.next
            pNode = pNode.next#沿着父节点向上遍历
        return  #到了根节点仍没找到，则返回空
