94.二叉树的中序遍历
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
思路：定义了一个list来进行传递
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res=[]
        return self.p(root,res)
    def p(self,root,res):
        if not root:
            return 
        self.p(root.left,res)
        res.append(root.val)
        self.p(root.right,res)
        return res
98. 验证二叉搜索树
思路：因为二叉搜索树中序遍历是递增的,所以我们可以中序遍历判断前一数是否小于后一个数.
中序遍历可以用上一题的代码
def isValidBST(self, root: TreeNode) -> bool:
        res = []
        def helper(root):
            if not root:
                return 
            helper(root.left)
            res.append(root.val)
            helper(root.right)
        helper(root)
        #别忘了每个节点数值不一样
        return res == sorted(res) and len(set(res)) == len(res)
101.对称二叉树
思路https://zhuanlan.zhihu.com/p/70756777
逐一比较根结点是否相等，左右子节点是否对称
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        return self.check(root,root)
    def check(self,p1,p2):
        if p1==None and p2==None:
            return True
        if p1==None or p2==None:
            return False
        if p1.val!=p2.val:
            return False
        return p1.val==p2.val and self.check(p1.left,p2.right) and self.check(p1.right,p2.left)
102.二叉树的层次遍历
思路：https://zhuanlan.zhihu.com/p/70960724
tmp存节点的val，cur和nex存取的每一层的节点
def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []
        res = []
        cur_level = [root]
        while cur_level:
            tmp = []
            next_level = []
            for node in cur_level:
                #输出是[[3],[9,20],[15,7]]，每一层的节点放在同一个list里
                tmp.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            res.append(tmp)
            cur_level = next_level
        return res
103. 二叉树的锯齿形层次遍历
#思路：和层次遍历唯一的变化就是记录深度，当dep%2==1时，需要将val（而不是节点）反向一下即可
def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return [] 
        cur=[root]
        res=[]
        dep=0
        while cur:
            tem=[]
            nex=[]
            for i in cur:
                tem.append(i.val)
                if i.left:
                    nex.append(i.left)
                if i.right:
                    nex.append(i.right)
            if dep%2==1:
                tem=tem[::-1]               
            res.append(tem)
            cur=nex
            dep+=1
        return res
