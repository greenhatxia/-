题目：二叉树的镜像
思路在书上158，代码来自https://cuijiahua.com/blog/2017/12/basis_18.html
python函数参数改不改变的问题
python里有可变对象和不可变对象之分。只有传入的是不可变对象时，值才不发生改变，若是可变对象，就像c的指针，会改变参数。
不可变对象：Number ,String , Tuple，bool
可变对象： List , Set , Dictionary，class是可以改变内部的元素
def Mirror(self, root):
        # write code here
        if not root or (root.left==None and root.right==None):
            return None
        tmp=root.left
        root.left=root.right
        root.right=tmp
        self.Mirror(root.left)
        self.Mirror(root.right)
题目：从上往下打印二叉树
书上172的思路，https://cuijiahua.com/blog/2017/12/basis_22.html的代码
def PrintFromTopToBottom(self, root):
        if not root:
            return []
        result = []
        tmp = [root]
        while len(tmp):
            cur = tmp.pop(0)
            result.append(cur.val)#返回的是val值得list
            if cur.left:
                tmp.append(cur.left)
            if cur.right:
                tmp.append(cur.right)
        return result
进阶：分行从上往下打印二叉树
思路来自书上174，就是上面代码的基础上增加了两个变量进行判断
创建二维list：
result=[]
final=[]
for i in range(4):
    for j in range(4):
        result.append(i*4+j)
    final.append(result)
    result=[]
print(final)
结果：[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]
def printFromTopToBottom(self, root):
        if not root:
            return []
        tmp=[root]
        result=[]
        cur=1
        next=0
        final=[]
        while tmp:
            a=tmp.pop(0)
            cur-=1
            result.append(a.val)
            if a.left:
                next+=1
                tmp.append(a.left)
            if a.right:
                next+=1
                tmp.append(a.right)
            if cur==0:
                final.append(result)#记住这种创建二维list的方法！！！！
                result=[]#记得清空！！！！！！
                cur=next
                next=0
        return final
题目：按之字顺序打印二叉树
#不要看书上的思路，分析打印的形状，即可发现和上一题的区别在于偶数行时进行翻转
，所以只需要用一个even变量进行判断并翻转即可
def Print(self, root):
        if not root:
            return []
        tmp=[root]
        result=[]
        cur=1
        next=0
        final=[]
        even=1#比上一个题唯一的改变
        while tmp:
            a=tmp.pop(0)
            cur-=1
            result.append(a.val)
            if a.left:
                next+=1
                tmp.append(a.left)
            if a.right:
                next+=1
                tmp.append(a.right)
            if cur==0:
                even=1-even
                if even:
                    result.reverse()
                final.append(result)
                result=[]
                cur=next
                next=0
        return final
题目：二叉树中和为某一值的路径
思路书上184
代码https://www.nowcoder.com/questionTerminal/b736e784e3e34731af99065031301bca
def FindPath(self, root, expect):
        if not root:
            return []
        result=[]
        path=[]
        def find(root,path,currentsum):
            path.append(root)
            currentsum+=root.val
            if currentsum==expect and (not root.left) and (not root.right):
                #如果直接result.append(path)，
                #因为append是添加引用，下面的path.pop()最终会把path清空，会得到[]
                copy=[]#[]是一个新的对象，所以换了一个地址，不会覆盖之前的copy
                for i in path:
                    copy.append(i.val)
                result.append(copy)
            if currentsum<expect:
                if root.left:
                    find(root.left,path,currentsum )
                if root.right:
                    find(root.right,path,currentsum )
            #currentsum是不可变量，所以不需要currentsum-=root.val
            path.pop()
        find(root,path,0)
        return result
题目：二叉树的深度
def TreeDepth(self, pRoot):
        if pRoot is None:
            return 0
        count = max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1
        return count
题目：重建二叉树
书上思路63，代码来源https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6
def reConstructBinaryTree(self, pre, tin):
        if len(pre) == 0:
            return None
        else:
            root = TreeNode(pre[0])
            pos = tin.index(pre[0])#可用enumerate
            root.left = self.reConstructBinaryTree(pre[1:pos+1], tin[:pos])
            root.right = self.reConstructBinaryTree(pre[pos+1:], tin[pos+1:])
        return root
        
        
题目：树的子结构
链接：https://www.nowcoder.com/questionTerminal/6e196c44c7004d15b1610b9afca8bd88
def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        result = False
        if pRoot1 != None and pRoot2 != None:
                result = self.DoesTree1haveTree2(pRoot1, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.left, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.right, pRoot2)
        return result
    # 用于递归判断树的每个节点是否相同
    # 需要注意的地方是: 前两个if语句不可以颠倒顺序
    # 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误
    def DoesTree1haveTree2(self, pRoot1, pRoot2):
        if pRoot2 == None:
            return True
        if pRoot1 == None:
            return False
        if pRoot1.val != pRoot2.val:#比较的是val，不能if p1!=p2
            return False
        return self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) and self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)
题目：平衡二叉树
算法复杂度O(N)即书中的第二种方法，从下往上
链接：https://www.nowcoder.com/questionTerminal/8b3b95850edb4115918ecebdf1b4d222
class Solution:
    def IsBalanced_Solution(self, p):
        # write code here
        return self.dfs(p) != -1
    def dfs(self, p):
        if p is None:
            return 0
        left = self.dfs(p.left)
        if left==-1:#判断左子树是否平衡
            return -1
        right = self.dfs(p.right)
        if right==-1:#判断右子树是否平衡
            return -1
        if abs(left-right)>1:#判断本节点是否平衡
            return -1
        return max(left,right)+1#计算深度
题目：二叉树的下一个结点
思路书上66，代码https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e
def GetNext(self, pNode):
        # write code here
        if pNode.right:#有右子树
            p=pNode.right
            while p.left:
                p=p.left
            return p
        while pNode.next:#无右子树，则找第一个当前节点是父节点左孩子的节点
            if(pNode.next.left==pNode):
                return pNode.next
            pNode = pNode.next#沿着父节点向上遍历
        return  #到了根节点仍没找到，则返回空
题目：对称的二叉树
链接：https://www.nowcoder.com/questionTerminal/ff05d44dfdb04e1d83bdbdab320efbcb
def isSymmetrical(self, pRoot):
        if not pRoot:
            return True
        return self.compare(pRoot.left, pRoot.right)
 
    def compare(self, pRoot1, pRoot2):
        if not pRoot1 and not pRoot2:
            return True
        if not pRoot1 or not pRoot2:
            return False
        if pRoot1.val == pRoot2.val:
            if self.compare(pRoot1.left, pRoot2.right) and self.compare(pRoot1.right, pRoot2.left):
                return True
        return False
