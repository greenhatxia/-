对于找零问题有两个版本，一个是求找零后零钱的数量最少；另一种求找零的方案数。
题目1
题目描述：
现有的钱币：coins=[1,2,5,7,10]
找零：change（假定为正整数）
求解：如何用最少的钱币进行找零
思路https://blog.csdn.net/xiaolangmin/article/details/90211716
https://blog.csdn.net/asd136912/article/details/79080693
leetcode连接https://leetcode.com/problems/coin-change/submissions/
def coinChange(self, coins: List[int], amount: int) -> int:
        dp=[amount+1]*(amount+1)
        dp[0]=0
        for i in range(1,amount+1):
            for j in coins:
                #零钱小于目标金额，并且比之前的找零方案（dp[i]）数量少，遍历时硬币的面额逐渐变大，dp[i-j]+1是使用该硬币时一共所需要的硬币数量
                if j<=i and dp[i]>dp[i-j]+1:
                    dp[i]=dp[i-j]+1
        if dp[amount]==(amount+1):
            dp[amount]=-1
        return(dp[-1])

题目2：找零的方案数
题目描述：想兑换100元钱，有1,2,5,10四种钱，问总共有多少兑换方法
https://blog.csdn.net/callinglove/article/details/46421959
容易理解但是会超时的方法
def change(self, amount: int, coins: List[int]) -> int:
        if amount==0:
            return 1
        if amount<0 or len(coins)==0:
            return 0
        return self.change(amount-coins[-1],coins)+self.change(amount,coins[:-1])
必须使用动态规划的思路，参考https://buptwc.com/2018/07/10/Leetcode-518-Coin-Change-2/
https://www.cnblogs.com/lightwindy/p/8674222.html
自己列出例子进行推导更好理解
注意是将硬币面额放在外循环
def change(self, amount, coins):
        dp = [0] * (amount + 1)
        dp[0] = 1
        for c in coins:
            for x in range(c, amount + 1):
                #>=的等于是因为x-c=0，而dp[0]=1,表示刚好被一个硬币找零
                if x>=c:
                    dp[x] += dp[x - c]
        return dp[amount]　
