写出来当插入i以后的规律：
i = 1 ----> 1
i = 2 ----> 0
i = 3 ----> 0
i = 4 ----> 1
i = 5 ----> 0
i = 6 ----> 0
i = 7 ----> 1
………………
发现在区间[1,x]之间共计有 fuck(x) = (x+2)/3 个1，剩下的都满足要求
那么在区间[l, r]上的 r-l+1个 数字中，必须抠掉 fuck(r) - fuck(l-1) 个不满足要求的数字。
直接打印出来就可以了，O(1)，不需要循环遍历。


数学归纳法：
当k = 0的时候：
last[0] = 0、last[1] = 1、last[2] = 0成立
假设规律last[3k+1] = 1、last[3k] = 0、last[3k+2] = 0成立；
则对于任意k+1而言
last[3(k+1)] = last[(3k+2) + 1] = (0 + 3(k+1)%3)%3 = 0
last[3(k+1)+1] = (0 + (3(k+1)+1)%3)%3 = 1
last[3(k+1)+2] = (1 + (3(k+1)+2)%3)%3 = (1+2)%3 = 0
可见对任意k，上述规律恒成立。
综上，last[i] = i%3==1



我写的代码，时间复杂度O（1）
import sys
line=sys.stdin.readline()
l,r=map(int,line.strip().split())
r1=r-(int((r+2)/3))#要用int处理
l1=l-1-(int((l-1+2)/3))
print(r1-l1)
